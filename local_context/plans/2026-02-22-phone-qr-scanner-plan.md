# Phone-Assisted QR Scanner Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Let operators scan PhilSys National ID QR codes using their phone camera, with results pushed back to the PC in real-time via Laravel Reverb.

**Architecture:** PC displays a QR code linking to a one-time scan URL. Operator opens it on their phone, scans the PhilSys ID. Phone POSTs the result to the server, which broadcasts a `ScanCompleted` event via Reverb. PC receives it instantly via Laravel Echo and auto-fills the form.

**Tech Stack:** Laravel 12, Laravel Reverb, Laravel Echo, Alpine.js, html5-qrcode, qrcode (npm), Blade

---

### Task 1: Install and Configure Laravel Reverb

**Files:**
- Modify: `.env`
- Modify: `resources/js/bootstrap.js`
- Create: `routes/channels.php` (generated by artisan)
- Modify: `composer.json` / `package.json` (via install commands)

**Step 1: Install broadcasting with Reverb**

Run:
```bash
php artisan install:broadcasting
```

This will:
- Install `laravel/reverb` (composer)
- Install `laravel-echo` and `pusher-js` (npm)
- Create `routes/channels.php`
- Create `config/broadcasting.php`
- Update `resources/js/bootstrap.js` with Echo setup

When prompted, answer **yes** to install Reverb.

**Step 2: Verify .env has Reverb settings**

The installer should add these to `.env`. Verify they exist:
```
BROADCAST_CONNECTION=reverb
REVERB_APP_ID=...
REVERB_APP_KEY=...
REVERB_APP_SECRET=...
REVERB_HOST=localhost
REVERB_PORT=8080
REVERB_SCHEME=http
VITE_REVERB_APP_KEY="${REVERB_APP_KEY}"
VITE_REVERB_HOST="${REVERB_HOST}"
VITE_REVERB_PORT="${REVERB_PORT}"
VITE_REVERB_SCHEME="${REVERB_SCHEME}"
```

**Step 3: Verify bootstrap.js was updated**

Read `resources/js/bootstrap.js` and confirm it now has `Echo` initialization. It should look like:
```js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
    broadcaster: 'reverb',
    key: import.meta.env.VITE_REVERB_APP_KEY,
    wsHost: import.meta.env.VITE_REVERB_HOST,
    wsPort: import.meta.env.VITE_REVERB_PORT ?? 80,
    wssPort: import.meta.env.VITE_REVERB_PORT ?? 443,
    forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
    enabledTransports: ['ws', 'wss'],
});
```

**Step 4: Test Reverb starts**

Run: `php artisan reverb:start`
Expected: Reverb server starts on port 8080 with no errors.
Stop it with Ctrl+C.

**Step 5: Commit**

```bash
git add -A
git commit -m "chore: install Laravel Reverb broadcasting infrastructure"
```

---

### Task 2: Create ScanSession Model and Migration

**Files:**
- Create: `database/migrations/2026_02_22_100000_create_scan_sessions_table.php`
- Create: `app/Models/ScanSession.php`

**Step 1: Create the migration**

Create file `database/migrations/2026_02_22_100000_create_scan_sessions_table.php`:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('scan_sessions', function (Blueprint $table) {
            $table->id();
            $table->string('token', 64)->unique();
            $table->enum('status', ['pending', 'completed', 'expired'])->default('pending');
            $table->json('scanned_data')->nullable();
            $table->dateTime('expires_at');
            $table->dateTime('completed_at')->nullable();
            $table->unsignedBigInteger('created_by');
            $table->timestamps();

            $table->index('token');
            $table->index(['status', 'expires_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('scan_sessions');
    }
};
```

**Step 2: Create the model**

Create file `app/Models/ScanSession.php`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class ScanSession extends Model
{
    protected $table = 'scan_sessions';

    protected $fillable = [
        'token',
        'status',
        'scanned_data',
        'expires_at',
        'completed_at',
        'created_by',
    ];

    protected $casts = [
        'scanned_data' => 'array',
        'expires_at' => 'datetime',
        'completed_at' => 'datetime',
    ];

    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by', 'id');
    }

    public function isExpired(): bool
    {
        return $this->expires_at->isPast();
    }

    public function isPending(): bool
    {
        return $this->status === 'pending' && !$this->isExpired();
    }

    public static function generateToken(): string
    {
        return bin2hex(random_bytes(32));
    }
}
```

**Step 3: Run the migration**

Run: `php artisan migrate`
Expected: Migration runs successfully, `scan_sessions` table created.

**Step 4: Commit**

```bash
git add database/migrations/2026_02_22_100000_create_scan_sessions_table.php app/Models/ScanSession.php
git commit -m "feat(scan): add ScanSession model and migration"
```

---

### Task 3: Create ScanCompleted Event

**Files:**
- Create: `app/Events/ScanCompleted.php`
- Modify: `routes/channels.php`

**Step 1: Create the broadcast event**

Create file `app/Events/ScanCompleted.php`:

```php
<?php

namespace App\Events;

use App\Models\ScanSession;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ScanCompleted implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(
        public ScanSession $scanSession
    ) {}

    public function broadcastOn(): array
    {
        return [
            new Channel('scan-session.' . $this->scanSession->token),
        ];
    }

    public function broadcastWith(): array
    {
        return [
            'raw_data' => $this->scanSession->scanned_data['raw_data'] ?? '',
            'format' => $this->scanSession->scanned_data['format'] ?? 'unknown',
        ];
    }

    public function broadcastAs(): string
    {
        return 'scan.completed';
    }
}
```

**Step 2: Add channel authorization**

Open `routes/channels.php` (created by Reverb installer in Task 1). Add:

```php
<?php

use App\Models\ScanSession;
use Illuminate\Support\Facades\Broadcast;

// Authorize scan session channel — only the user who created the session can listen
Broadcast::channel('scan-session.{token}', function ($user, $token) {
    $session = ScanSession::where('token', $token)->first();
    return $session && $session->created_by === $user->id;
});
```

**Note:** We're using a public `Channel` (not `PrivateChannel`) in the event because the phone page is unauthenticated. The channel name itself contains a cryptographically random 64-char token which serves as the authorization. If you prefer stricter auth, switch to `PrivateChannel` — but then the channel authorization closure above must work, and only the PC (authenticated) side listens.

**Actually — correction:** Since only the PC (authenticated user) listens and the phone only POSTs to an API endpoint (doesn't subscribe to the channel), we CAN use `PrivateChannel`. Let me correct the event:

Replace `new Channel(...)` with `new \Illuminate\Broadcasting\PrivateChannel(...)` in the event:

```php
public function broadcastOn(): array
{
    return [
        new \Illuminate\Broadcasting\PrivateChannel('scan-session.' . $this->scanSession->token),
    ];
}
```

**Step 3: Commit**

```bash
git add app/Events/ScanCompleted.php routes/channels.php
git commit -m "feat(scan): add ScanCompleted broadcast event and channel auth"
```

---

### Task 4: Create ScanSessionController and Routes

**Files:**
- Create: `app/Http/Controllers/ScanSessionController.php`
- Modify: `routes/web.php`
- Modify: `routes/api.php`

**Step 1: Create the controller**

Create file `app/Http/Controllers/ScanSessionController.php`:

```php
<?php

namespace App\Http\Controllers;

use App\Events\ScanCompleted;
use App\Models\ScanSession;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class ScanSessionController extends Controller
{
    /**
     * Create a new scan session (called from PC).
     * Returns the token for QR code generation.
     */
    public function store(Request $request): JsonResponse
    {
        $session = ScanSession::create([
            'token' => ScanSession::generateToken(),
            'status' => 'pending',
            'expires_at' => now()->addMinutes(5),
            'created_by' => $request->user()->id,
        ]);

        return response()->json([
            'success' => true,
            'token' => $session->token,
            'scan_url' => url('/scan/' . $session->token),
            'expires_at' => $session->expires_at->toISOString(),
        ]);
    }

    /**
     * Phone scanning page (public, token-validated).
     */
    public function show(string $token)
    {
        $session = ScanSession::where('token', $token)->first();

        if (!$session || $session->status === 'completed') {
            return view('scan.expired', ['reason' => 'used']);
        }

        if ($session->isExpired()) {
            $session->update(['status' => 'expired']);
            return view('scan.expired', ['reason' => 'expired']);
        }

        return view('scan.show', ['token' => $token]);
    }

    /**
     * Receive scanned data from phone (public, token-validated).
     */
    public function submit(Request $request, string $token): JsonResponse
    {
        $session = ScanSession::where('token', $token)
            ->where('status', 'pending')
            ->first();

        if (!$session) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid or expired scan session.',
            ], 404);
        }

        if ($session->isExpired()) {
            $session->update(['status' => 'expired']);
            return response()->json([
                'success' => false,
                'message' => 'Scan session has expired.',
            ], 410);
        }

        $validated = $request->validate([
            'raw_data' => 'required|string',
            'format' => 'nullable|string|max:50',
        ]);

        $session->update([
            'status' => 'completed',
            'scanned_data' => $validated,
            'completed_at' => now(),
        ]);

        broadcast(new ScanCompleted($session));

        return response()->json([
            'success' => true,
            'message' => 'Scan received successfully.',
        ]);
    }
}
```

**Step 2: Add routes**

Add to `routes/web.php` (OUTSIDE the auth middleware group — this is a public page):

```php
// Phone QR scanning page (public, token-validated)
Route::get('/scan/{token}', [App\Http\Controllers\ScanSessionController::class, 'show'])
    ->name('scan.show');
```

Add to `routes/api.php`:

```php
// Scan session API
Route::post('/scan-sessions', [App\Http\Controllers\ScanSessionController::class, 'store'])
    ->middleware('auth:sanctum')
    ->name('api.scan-sessions.store');

// Phone submits scanned data (public, token-validated)
Route::post('/scan/{token}', [App\Http\Controllers\ScanSessionController::class, 'submit'])
    ->name('api.scan.submit');
```

**Important:** The `store` route needs auth. Check how other authenticated API routes work in this project. Looking at the codebase, many API-like routes live in `web.php` under the `auth` middleware. If that's simpler, put the `store` route there instead:

```php
// Inside the Route::middleware('auth')->group(function () { ... }):
Route::post('/api/scan-sessions', [ScanSessionController::class, 'store'])->name('api.scan-sessions.store');
```

This avoids needing Sanctum for this route since the PC is already authenticated via session cookie.

**Step 3: Verify routes**

Run: `php artisan route:list --name=scan`
Expected: All 3 scan routes listed.

**Step 4: Commit**

```bash
git add app/Http/Controllers/ScanSessionController.php routes/web.php routes/api.php
git commit -m "feat(scan): add ScanSessionController with create, show, and submit endpoints"
```

---

### Task 5: Create Phone Scanning Blade Views

**Files:**
- Create: `resources/views/scan/show.blade.php` (phone scanning page)
- Create: `resources/views/scan/expired.blade.php` (expired/used token page)

**Step 1: Create the phone scanning page**

Create file `resources/views/scan/show.blade.php`:

This is a standalone page using the `guest.blade.php` layout (minimal, no app chrome). It needs:
- Full-viewport mobile-optimized layout
- Camera scanner using `html5-qrcode` (already bundled in `app.js`)
- Auto-submit on successful scan via `fetch()` POST to `/api/scan/{token}`
- Success screen after submission
- Fallback file upload if no camera access

```blade
<x-guest-layout>
    @push('styles')
    <style>
        /* Full-viewport mobile scanner */
        .scan-page { min-height: 100dvh; display: flex; flex-direction: column; }
        .scanner-container { flex: 1; position: relative; overflow: hidden; }
        #phone-qr-reader video { width: 100% !important; height: 100% !important; object-fit: cover; }
    </style>
    @endpush

    <div x-data="phoneScanApp('{{ $token }}')" class="scan-page bg-gray-900">
        {{-- Header --}}
        <div class="bg-white dark:bg-gray-800 px-4 py-3 shadow-sm flex items-center gap-3">
            <div class="w-8 h-8 rounded-lg bg-purple-100 dark:bg-purple-900/30 flex items-center justify-center">
                <i class="fas fa-qrcode text-purple-600 dark:text-purple-400"></i>
            </div>
            <div>
                <h1 class="text-sm font-bold text-gray-900 dark:text-white">Scan National ID</h1>
                <p class="text-xs text-gray-500 dark:text-gray-400">Point camera at the QR code</p>
            </div>
        </div>

        {{-- Scanner --}}
        <div x-show="state === 'scanning'" class="scanner-container">
            <div id="phone-qr-reader" class="w-full h-full"></div>

            {{-- Scanning indicator --}}
            <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4">
                <div class="flex items-center justify-center gap-2">
                    <span class="relative flex h-3 w-3">
                        <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                        <span class="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
                    </span>
                    <span class="text-sm text-white font-medium">Scanning...</span>
                </div>
            </div>
        </div>

        {{-- Submitting state --}}
        <div x-show="state === 'submitting'" class="flex-1 flex items-center justify-center bg-gray-900">
            <div class="text-center px-6">
                <i class="fas fa-spinner fa-spin text-4xl text-purple-400 mb-4"></i>
                <p class="text-lg font-semibold text-white">Sending to computer...</p>
                <p class="text-sm text-gray-400 mt-1">Please wait</p>
            </div>
        </div>

        {{-- Success state --}}
        <div x-show="state === 'success'" class="flex-1 flex items-center justify-center bg-gray-900">
            <div class="text-center px-6">
                <div class="w-20 h-20 mx-auto rounded-full bg-green-500/20 flex items-center justify-center mb-4">
                    <i class="fas fa-check text-green-400 text-4xl"></i>
                </div>
                <p class="text-xl font-bold text-white">Scanned Successfully!</p>
                <p class="text-sm text-gray-400 mt-2">You can return to your computer.</p>
            </div>
        </div>

        {{-- Error state --}}
        <div x-show="state === 'error'" class="flex-1 flex items-center justify-center bg-gray-900 px-6">
            <div class="text-center">
                <div class="w-20 h-20 mx-auto rounded-full bg-red-500/20 flex items-center justify-center mb-4">
                    <i class="fas fa-exclamation-triangle text-red-400 text-3xl"></i>
                </div>
                <p class="text-lg font-bold text-white mb-2">Something went wrong</p>
                <p class="text-sm text-gray-400 mb-4" x-text="errorMessage"></p>
                <button @click="retry()" class="px-6 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg font-medium">
                    Try Again
                </button>
            </div>
        </div>
    </div>

    @push('scripts')
    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('phoneScanApp', (token) => ({
                state: 'scanning', // scanning | submitting | success | error
                errorMessage: '',
                scanner: null,

                init() {
                    this.$nextTick(() => this.startScanning());
                },

                async startScanning() {
                    const { Html5Qrcode } = await import('html5-qrcode');
                    this.scanner = new Html5Qrcode('phone-qr-reader', {
                        verbose: false,
                        experimentalFeatures: { useBarCodeDetectorIfSupported: true }
                    });

                    try {
                        await this.scanner.start(
                            { facingMode: 'environment' },
                            { fps: 15, disableFlip: false },
                            (decodedText, decodedResult) => this.onScanSuccess(decodedText, decodedResult),
                            () => {}
                        );
                    } catch (err) {
                        console.error('[Phone Scanner] Camera failed:', err);
                        this.state = 'error';
                        this.errorMessage = 'Could not access camera. Please check permissions.';
                    }
                },

                async onScanSuccess(decodedText, decodedResult) {
                    // Prevent double-submit
                    if (this.state !== 'scanning') return;

                    const format = decodedResult?.result?.format?.formatName || 'unknown';
                    console.log('[Phone Scanner] Scanned:', format, decodedText.substring(0, 80));

                    // Stop camera
                    if (this.scanner) {
                        try { await this.scanner.stop(); } catch (e) {}
                    }

                    this.state = 'submitting';
                    await this.submitResult(decodedText, format);
                },

                async submitResult(rawData, format, retries = 3) {
                    for (let attempt = 1; attempt <= retries; attempt++) {
                        try {
                            const response = await fetch(`/api/scan/${token}`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json',
                                    'X-Requested-With': 'XMLHttpRequest',
                                },
                                body: JSON.stringify({ raw_data: rawData, format }),
                            });

                            const data = await response.json();

                            if (data.success) {
                                this.state = 'success';
                                return;
                            } else {
                                throw new Error(data.message || 'Submission failed');
                            }
                        } catch (err) {
                            console.warn(`[Phone Scanner] Submit attempt ${attempt} failed:`, err);
                            if (attempt === retries) {
                                this.state = 'error';
                                this.errorMessage = err.message || 'Failed to send scan result. Check your connection.';
                            }
                            // Wait before retry
                            await new Promise(r => setTimeout(r, 1000));
                        }
                    }
                },

                retry() {
                    this.state = 'scanning';
                    this.errorMessage = '';
                    this.$nextTick(() => this.startScanning());
                },
            }));
        });
    </script>
    @endpush
</x-guest-layout>
```

**Step 2: Create the expired/used token page**

Create file `resources/views/scan/expired.blade.php`:

```blade
<x-guest-layout>
    <div class="min-h-screen flex items-center justify-center bg-gray-900 px-6">
        <div class="text-center">
            <div class="w-20 h-20 mx-auto rounded-full bg-amber-500/20 flex items-center justify-center mb-4">
                <i class="fas fa-clock text-amber-400 text-3xl"></i>
            </div>
            <p class="text-xl font-bold text-white mb-2">
                @if($reason === 'used')
                    Link Already Used
                @else
                    Link Expired
                @endif
            </p>
            <p class="text-sm text-gray-400">
                @if($reason === 'used')
                    This scan link has already been used. Please generate a new one from your computer.
                @else
                    This scan link has expired. Please generate a new one from your computer.
                @endif
            </p>
        </div>
    </div>
</x-guest-layout>
```

**Step 3: Verify views render**

Visit `http://localhost:8000/scan/invalid-token` in your browser.
Expected: Should show the expired page since the token doesn't exist.

**Step 4: Commit**

```bash
git add resources/views/scan/
git commit -m "feat(scan): add phone scanning and expired token Blade views"
```

---

### Task 6: Install QR Code Library and Update PC-Side Modal

**Files:**
- Modify: `resources/js/components/qr-scanner.js` — rewrite for phone-scan tab + upload tab
- Modify: `resources/views/pages/application/service-application.blade.php` — update modal HTML
- Install: `qrcode` npm package

**Step 1: Install qrcode library**

Run: `npm install qrcode`

This is a client-side QR code generator — renders the scan URL as a QR code image.

**Step 2: Rewrite qr-scanner.js**

Replace the entire file with a new component that has two modes:
- **Phone scan mode:** Creates a session, displays QR code, listens on Echo private channel
- **Upload mode:** Keeps existing jsQR + binarization file upload logic

```js
import jsQR from 'jsqr';
import QRCode from 'qrcode';

// ─── Image Processing (kept from upload implementation) ─────────

function getImageData(source, crop = null) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const sw = source.naturalWidth || source.videoWidth || source.width;
    const sh = source.naturalHeight || source.videoHeight || source.height;
    if (crop) {
        canvas.width = crop.w;
        canvas.height = crop.h;
        ctx.drawImage(source, crop.x, crop.y, crop.w, crop.h, 0, 0, crop.w, crop.h);
    } else {
        canvas.width = sw;
        canvas.height = sh;
        ctx.drawImage(source, 0, 0);
    }
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function binarize(imageData) {
    const data = imageData.data;
    const len = data.length / 4;
    const gray = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        const idx = i * 4;
        gray[i] = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
    }
    const histogram = new Array(256).fill(0);
    for (let i = 0; i < len; i++) histogram[gray[i]]++;
    let sum = 0;
    for (let i = 0; i < 256; i++) sum += i * histogram[i];
    let sumB = 0, wB = 0, maxVar = 0, threshold = 128;
    for (let t = 0; t < 256; t++) {
        wB += histogram[t];
        if (wB === 0) continue;
        const wF = len - wB;
        if (wF === 0) break;
        sumB += t * histogram[t];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        const variance = wB * wF * (mB - mF) * (mB - mF);
        if (variance > maxVar) { maxVar = variance; threshold = t; }
    }
    for (let i = 0; i < len; i++) {
        const val = gray[i] > threshold ? 255 : 0;
        const idx = i * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = val;
    }
    return imageData;
}

function tryJsQR(imageData) {
    const code = jsQR(imageData.data, imageData.width, imageData.height, {
        inversionAttempts: 'attemptBoth',
    });
    return code ? code.data : null;
}

function loadImage(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Failed to load image')); };
        img.src = url;
    });
}

// ─── Alpine Component ───────────────────────────────────────────

document.addEventListener('alpine:init', () => {
    Alpine.data('qrScanner', () => ({
        isOpen: false,
        isCaptured: false,
        isProcessingFile: false,
        error: '',
        mode: 'phone',       // 'phone' or 'upload'
        rawResult: '',

        // Phone scan state
        scanToken: '',
        scanUrl: '',
        qrCodeDataUrl: '',
        expiresAt: null,
        countdown: '',
        isExpired: false,
        isWaiting: false,
        _countdownTimer: null,
        _echoChannel: null,

        openScanner() {
            this.isOpen = true;
            this.error = '';
            this.rawResult = '';
            this.isCaptured = false;
            this.mode = 'phone';

            this.$nextTick(() => this.createScanSession());
        },

        async switchMode(newMode) {
            if (this.mode === newMode) return;
            this.error = '';
            this.rawResult = '';
            this.isCaptured = false;

            if (this.mode === 'phone') {
                this._cleanupPhoneSession();
            }

            this.mode = newMode;

            if (newMode === 'phone') {
                this.$nextTick(() => this.createScanSession());
            }
        },

        // ─── Phone Scan Mode ──────────────────────────────────

        async createScanSession() {
            this.isWaiting = true;
            this.isExpired = false;
            this.error = '';
            this.scanToken = '';
            this.qrCodeDataUrl = '';
            this.countdown = '';

            try {
                const response = await fetch('/api/scan-sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').content,
                        'X-Requested-With': 'XMLHttpRequest',
                    },
                });

                const data = await response.json();
                if (!data.success) throw new Error(data.message || 'Failed to create session');

                this.scanToken = data.token;
                this.scanUrl = data.scan_url;
                this.expiresAt = new Date(data.expires_at);

                // Generate QR code image from the scan URL
                this.qrCodeDataUrl = await QRCode.toDataURL(data.scan_url, {
                    width: 280,
                    margin: 2,
                    color: { dark: '#1f2937', light: '#ffffff' },
                });

                // Start countdown timer
                this._startCountdown();

                // Listen for scan result via Echo
                this._listenForResult();

            } catch (err) {
                console.error('[QR Scanner] Failed to create session:', err);
                this.error = 'Failed to create scan session. Please try again.';
                this.isWaiting = false;
            }
        },

        _startCountdown() {
            this._countdownTimer = setInterval(() => {
                const now = new Date();
                const diff = this.expiresAt - now;

                if (diff <= 0) {
                    this.isExpired = true;
                    this.countdown = 'Expired';
                    this._cleanupPhoneSession();
                    return;
                }

                const mins = Math.floor(diff / 60000);
                const secs = Math.floor((diff % 60000) / 1000);
                this.countdown = `${mins}:${secs.toString().padStart(2, '0')}`;
            }, 1000);
        },

        _listenForResult() {
            if (!window.Echo) {
                console.error('[QR Scanner] Echo not available');
                return;
            }

            this._echoChannel = window.Echo.private(`scan-session.${this.scanToken}`)
                .listen('.scan.completed', (data) => {
                    console.log('[QR Scanner] Received scan result via Reverb:', data);
                    this._cleanupPhoneSession();
                    this.isWaiting = false;
                    this.showCapturedResult(data.raw_data);
                });
        },

        regenerateSession() {
            this._cleanupPhoneSession();
            this.createScanSession();
        },

        _cleanupPhoneSession() {
            if (this._countdownTimer) {
                clearInterval(this._countdownTimer);
                this._countdownTimer = null;
            }
            if (this._echoChannel && window.Echo) {
                window.Echo.leave(`scan-session.${this.scanToken}`);
                this._echoChannel = null;
            }
        },

        // ─── Upload Mode ──────────────────────────────────────

        async handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            this.error = '';
            this.rawResult = '';
            this.isCaptured = false;
            this.isProcessingFile = true;

            try {
                const img = await loadImage(file);
                const iw = img.naturalWidth;
                const ih = img.naturalHeight;

                // Attempt 1: jsQR on full image
                let result = tryJsQR(getImageData(img));

                // Attempt 2: jsQR on binarized full image
                if (!result) result = tryJsQR(binarize(getImageData(img)));

                // Attempt 3: jsQR on right half (binarized) — PhilSys QR is on the right
                if (!result) {
                    const crop = { x: Math.floor(iw * 0.4), y: 0, w: Math.ceil(iw * 0.6), h: ih };
                    result = tryJsQR(binarize(getImageData(img, crop)));
                }

                // Attempt 4: Native BarcodeDetector
                if (!result && 'BarcodeDetector' in window) {
                    try {
                        const detector = new BarcodeDetector({ formats: ['qr_code', 'pdf417', 'data_matrix', 'aztec'] });
                        const barcodes = await detector.detect(img);
                        if (barcodes.length > 0) result = barcodes[0].rawValue;
                    } catch (e) {}
                }

                if (result) {
                    this.showCapturedResult(result);
                } else {
                    this.error = 'Could not detect a barcode. Make sure the QR code is clearly visible.';
                }
            } catch (err) {
                this.error = 'Failed to load the image file.';
            } finally {
                this.isProcessingFile = false;
                event.target.value = '';
            }
        },

        // ─── Shared ──────────────────────────────────────────

        showCapturedResult(text) {
            this.isCaptured = true;
            setTimeout(() => {
                this.rawResult = text;
                this.isCaptured = false;
            }, 800);
        },

        scanAgain() {
            this.rawResult = '';
            this.error = '';
            this.isCaptured = false;

            if (this.mode === 'phone') {
                this.createScanSession();
            }
        },

        async closeScanner() {
            this._cleanupPhoneSession();
            this.isOpen = false;
            this.isWaiting = false;
            this.isProcessingFile = false;
            this.isCaptured = false;
            this.error = '';
            this.rawResult = '';
            this.mode = 'phone';
            this.qrCodeDataUrl = '';
            this.scanToken = '';
        }
    }));
});
```

**Step 3: Update the Blade modal**

In `resources/views/pages/application/service-application.blade.php`, replace the QR scanner modal body with:
- **Tab 1: "Scan with Phone"** — shows generated QR code, waiting status, countdown, regenerate button
- **Tab 2: "Upload Image"** — keeps existing upload dropzone

Update the tab buttons (`Camera` → `Scan with Phone`) and the camera mode div → phone scan mode div.

The phone scan tab content:
```blade
<!-- Phone Scan Mode -->
<div x-show="mode === 'phone' && !rawResult && !isCaptured">
    <div class="flex flex-col items-center py-4">
        <!-- QR Code Display -->
        <div x-show="qrCodeDataUrl && !isExpired" class="text-center">
            <img :src="qrCodeDataUrl" alt="Scan this QR code" class="mx-auto rounded-lg border border-gray-200 dark:border-gray-600">
            <p class="mt-3 text-sm text-gray-600 dark:text-gray-400">
                Scan this code with your phone camera
            </p>
            <!-- Waiting indicator -->
            <div class="mt-3 flex items-center justify-center gap-2">
                <span class="relative flex h-2.5 w-2.5">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-purple-400 opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2.5 w-2.5 bg-purple-500"></span>
                </span>
                <span class="text-xs text-gray-500 dark:text-gray-400">Waiting for phone...</span>
            </div>
            <!-- Countdown -->
            <p class="mt-2 text-xs text-gray-400 dark:text-gray-500">
                Link expires in <span class="font-mono font-semibold" x-text="countdown"></span>
            </p>
        </div>

        <!-- Expired state -->
        <div x-show="isExpired" class="text-center py-6">
            <i class="fas fa-clock text-3xl text-amber-400 mb-3"></i>
            <p class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">Link expired</p>
            <button @click="regenerateSession()" type="button"
                    class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white text-sm font-medium rounded-lg transition-colors">
                <i class="fas fa-redo mr-2"></i>Generate New Link
            </button>
        </div>

        <!-- Loading state -->
        <div x-show="!qrCodeDataUrl && !isExpired && !error" class="text-center py-8">
            <i class="fas fa-spinner fa-spin text-2xl text-purple-500 mb-3"></i>
            <p class="text-sm text-gray-500">Generating scan link...</p>
        </div>
    </div>
</div>
```

**Step 4: Verify the build**

Run: `npm run build` (or rely on HMR with `npm run dev`)
Expected: No build errors.

**Step 5: Commit**

```bash
git add resources/js/components/qr-scanner.js resources/views/pages/application/service-application.blade.php package.json package-lock.json
git commit -m "feat(scan): rewrite QR scanner modal with phone-scan and upload tabs"
```

---

### Task 7: Wire Up handleQrScanned and End-to-End Test

**Files:**
- Modify: `resources/views/pages/application/service-application.blade.php` — ensure `handleQrScanned` dispatches correctly

**Step 1: Verify handleQrScanned still works**

The existing `handleQrScanned(data)` method in the `serviceApplicationWizard()` Alpine component should already handle the raw QR data. When the scan result arrives (from either phone or upload), the qr-scanner component should dispatch an event:

In the `showCapturedResult` method, after showing the result, dispatch:
```js
this.$dispatch('qr-scanned', { rawData: text });
```

The existing `@qr-scanned.window="handleQrScanned($event.detail)"` listener on the parent component will pick it up.

Verify `handleQrScanned` in the service application wizard parses the raw data and fills the form fields.

**Step 2: End-to-end test**

1. Start Reverb: `php artisan reverb:start`
2. Start dev server: `php artisan serve`
3. Start Vite: `npm run dev`
4. Navigate to Service Application form → click "Scan National ID"
5. Modal opens → "Scan with Phone" tab shows QR code
6. Open phone → scan the QR code on screen → phone opens scanning page
7. On phone, scan a QR code (any QR code for testing)
8. PC modal should instantly show the scanned result
9. Test "Upload Image" tab with the PhilSys ID image
10. Test expired link (wait 5 minutes or manually update DB)
11. Test regenerate button

**Step 3: Commit**

```bash
git add -A
git commit -m "feat(scan): wire up QR result dispatch and verify end-to-end flow"
```

---

### Task 8: Add Reverb to Dev Server Command

**Files:**
- Modify: `composer.json` (the `dev` script)

**Step 1: Check current dev command**

Read `composer.json` to see the current `scripts.dev` command. It likely uses `concurrently` or `php artisan serve` alongside Vite.

**Step 2: Add Reverb to the dev command**

Add `php artisan reverb:start` to the concurrent dev processes so Reverb starts automatically when the developer runs `composer dev`.

For example, if using the `dev` script pattern:
```json
"dev": "npx concurrently \"php artisan serve\" \"php artisan queue:work\" \"php artisan reverb:start\" \"npm run dev\" --names=server,queue,reverb,vite"
```

**Step 3: Test the combined dev command**

Run: `composer dev`
Expected: All processes start (Laravel server, queue worker, Reverb, Vite).

**Step 4: Commit**

```bash
git add composer.json
git commit -m "chore: add Reverb to dev server command"
```

---

### Task 9: Cleanup Old Camera Scanner Code

**Files:**
- Possibly remove: Camera-related code from `qr-scanner.js` (already done in Task 6)
- Verify: No dead imports (`html5-qrcode` may still be needed for the phone page)
- Verify: `philsys-parser.js` is imported where needed (in `handleQrScanned`)

**Step 1: Review imports in app.js**

Ensure `app.js` still imports:
- `./components/qr-scanner.js` (the rewritten version)
- `./parsers/philsys-parser.js` may need to be imported in the Blade `<script>` where `handleQrScanned` lives, or exported globally

**Step 2: Remove unused npm packages if any**

Check if `html5-qrcode` is still needed:
- YES — it's used on the phone scanning page (`scan/show.blade.php`)
- `jsqr` — still used in the upload flow

Both should stay.

**Step 3: Run `./vendor/bin/pint`**

Format all PHP files to PSR-12.

**Step 4: Run tests**

Run: `php artisan test`
Expected: All existing tests pass (no regressions).

**Step 5: Final commit**

```bash
git add -A
git commit -m "chore: cleanup imports and format code"
```

---

## Summary

| Task | What | Estimated Steps |
|------|------|----------------|
| 1 | Install Laravel Reverb | 5 steps |
| 2 | ScanSession model + migration | 4 steps |
| 3 | ScanCompleted event + channels | 3 steps |
| 4 | Controller + routes | 4 steps |
| 5 | Phone scanning Blade views | 4 steps |
| 6 | PC modal rewrite + qrcode lib | 5 steps |
| 7 | Wire up handleQrScanned + E2E test | 3 steps |
| 8 | Add Reverb to dev command | 4 steps |
| 9 | Cleanup + format + test | 5 steps |
